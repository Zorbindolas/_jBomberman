package controller;

import java.util.Observer;

import model.Dir;
import model.GameModel;
import model.ModelTimer;
import view.EnjoyNpcMediator;
import view.EnjoyPowerUpMediator;
import view.DynaSlaveCard;
import view.DynaSlaveGame;
/**
 * This class models the algorithms which create a game session.
 * Each game session has its unique ThreadGame instance: it is generated by the ThreadMenu
 * following the inputs produced by the User and it is terminated with the game session.
 */
@SuppressWarnings("deprecation")
public class ThreadGame extends ThreadDelta {
	/**
	 * Current concrete state. 
	 * State Design Pattern manages contexts of the game (PLAY,PAUSE,CONTINUE...).
	 */
	private StateAbstract currentState;
	/**
	 * Extended DynaSlaveCard from DynaFrame's CardLayout in which game view is drawn.  
	 */
	private DynaSlaveGame gamePanel;
	/**
	 * Time of gameplay in seconds.
	 */
	private int speedrunTime;
	// Utility References
	/**
	 * Utility reference of DynaManager (reducing wordiness).
	 */
	private DynaManager dm;
	/**
	 * The specific KeyListener to interpret inputs during game play.
	 */
	private KeyListenerGame keyLis;
	// Boolean conditions
	/**
	 * Condition to switch from current game state to another. 
	 */
	private boolean gameOver, gameWin, escape;
	/**
	 * Condition to exit from game play without gameOver registered.
	 */
	private boolean neverLose;
	// User's inputs
	/**
	 * Direction produced by User.
	 */
	private Dir direction;
	/**
	 * Command produced by User's input.
	 */
	private boolean performAction, triggerAction, pause;
	
	private boolean victory;
	/**
	 * Constructor of this ThreadGame
	 */
	public ThreadGame() {					

		this.dm = DynaManager.getInstance();
		this.keyLis = KeyListenerGame.getInstance();	

		this.direction = Dir.RIGHT;
		this.performAction = false;
		this.neverLose = true;
		
	}
	
	// Getters
	/**
	 * Getter of the current DynaSlaveGame
	 * @return this current DynaSlaveGame
	 */
	public DynaSlaveGame getPanel() {return gamePanel;}
	/**
	 * Getter of the current direction
	 * @return the current direction
	 */
	public Dir getDirection() {return direction;}
	/**
	 * Getter of performedAction
	 * @return true if User has produced action input
	 */
	public boolean isPerformedAction() {return performAction;}
	/**
	 * Getter of triggerAction
	 * @return true if User has produced trigger input
	 * 
	 */
	public boolean isTriggerAction() {return triggerAction;}
	/**
	 * Getter of pause
	 * @return true if User has produced pause input
	 */
	public boolean isPaused() {return pause;}
	public boolean isVictory() {return victory;}
	/**
	 * Getter of gameOver
	 * @return true if the current state must switch to continue or game over state
	 */
	public boolean isGameOver() {return gameOver;}
	/**
	 * Getter of gameWin
	 * @return true if the current state must switch to winlevel or winstage state
	 */
	public boolean isGameWin() {return gameWin;}
	/**
	 * Getter of escape
	 * @return true if the current state must terminate this thread
	 */
	public boolean isEscape() {return escape;}
	/**
	 * Getter of the current state
	 * @return this current state
	 */
	public StateAbstract getCurrentState() {return currentState;}
	/**
	 * Getter of neverLose
	 * @return true if the player never loses a life
	 */
	public boolean isNeverLose() {return neverLose;}
	
	// Setters
	/**
	 * Setter of pause
	 * @param pause new pause value
	 */
	public void setPause(boolean pause) {this.pause = pause;}
	/**
	 * Setter of gameOver
	 * @param gameOver new gameOver value
	 */
	public void setGameOver(boolean gameOver) {this.gameOver = gameOver;}
	/**
	 * Setter of gameWin
	 * @param gameWin new gameWin value
	 */
	public void setGameWin(boolean gameWin) {this.gameWin = gameWin;}
	/**
	 * Setter of escape
	 * @param escape new escape value
	 */
	public void setEscape(boolean escape) {this.escape = escape;}
	/**
	 * Setter of neverLose
	 * @param neverLose new neverLose value
	 */
	public void setNeverLose(boolean neverLose) {this.neverLose=neverLose;}
	// State Design Pattern
	/**
	 * Delegate the operations to be performed to those defined by the current state.
	 */
	public void currentStateOperations() {
		currentState.handleOperations();
	}
	/**
	 * Change the current state and inform the observers.
	 * The View has a State design Pattern mirroring that of ThreadGame.
	 * @param currentState new current concrete state
	 */
	public void setCurrentState(StateAbstract currentState) {
		this.currentState=currentState;
		GameModel.getInstance().changeState(currentState);
	}
	/**
	 * Run method implemented with Template Method Design Pattern.
	 * This method gets involved when ThreadMenu applies startThreadGame(), 
	 * because the DynaFrame.isTimeToPlay returns true.
	 * 
	 * DynaFrame.isTimeToPlay has resulted true the moment in which User just created
	 * an event in DynaSlaveStage that executed DynaSlaveStage.startThreadGame().
	 * So that Cardlayout Master has been removed from ObserverList and then CardLayout 
	 * switched its card off to show DynaSlaveGame (that is, current game session panel).
	 * 
	 * ThreadMenu.StartThreadGame() calls JBomberMan.runGameSession() 
	 * that initializes a new ThreadGame and applies .start(). 
	 * So that in this way such a method actually runs.
	 * 
	 * Now, ThreadMenu stays paused and it's waiting for the death of this ThreadGame to run back again.
	 */
	@Override
	public void run() {
		
		//System.out.println("TG: I wakes up!");
		
		loadPhase();
		
		// -------------------CONDITIONAL ARCHITECTURE----------------------   
		
		while(GameModel.getInstance().isGame()) {
			
			super.run();
			
			ender();	
	
		}

		//System.out.println("TG: I Die!");
	}
	
	// ----------------- Run's Template Method --------------------
	@Override
	protected void preparation() {
		gameOver = gameWin = escape = false;  // reset the conditions of -end game session-
		timerGeneral = 0;
	}

	@Override
	protected boolean loopCondition() {
		return !gameOver && !gameWin && !escape;
	}

	@Override
	protected void coreFunctions() {
		updateTimers(); // metronome for one second passed
		
		receivingOrders();  // PLAYING-TIMER is the timer "in game"
		
		currentStateOperations();
	}
	
	// ------ CLASS RUN' S SPECIAL METHODS ---------------------------------------
	/**
	 * Controller sets Game Model in order to exploit the Observable-Observer Design Pattern.
	 * DynaSlaveGame (View and now Observer too) gets updated by Game Model (Model and Observable) 
	 * notifications, which are provoked by this thread.
	 */
	private void loadPhase() {		
		/* LOAD ASSETS SELECTED BY THE VIEW, FROM MODEL, THEN DECORATED.
		 * DynaManager generates the decorated versions (Decorator Pattern)
		 * and loads them into the singleton Game Model (it works due to polymorphism)
		  */
		
		// remove Master from Observer List
		GameModel.getInstance().deleteObservers();
		/* 
		 * Now DynaSlaveGame is becoming observer of the GameModel,
		 * but I need to be sure that the CardLayout is already on DynaSlaveGame
		 */
		
		DynaSlaveCard hpCard;
		
		do {
			
			hpCard = dm.getFrame().getMaster().getActivePanel();
			
			if(hpCard instanceof DynaSlaveGame) {
				gamePanel = (DynaSlaveGame)hpCard;
				GameModel.getInstance().addObserver(
						(Observer) gamePanel
						);
			}
	
		} while (! (hpCard instanceof DynaSlaveGame) );
		
		/* I have to wait for data to be ready before using them */
		
		while(!GameModel.getInstance().isReady()) {
			//System.out.println("ready");
			try {
				Thread.sleep(500);
			} catch (InterruptedException e) {e.printStackTrace();}
		}; 		//System.out.println(timeToLoad);  // 2-3 sec loading
		
		dm.setActualLevel(
				dm.getFrame().getInitialSelectedStageLabel()
				,
				dm.getFrame().getInitialSelectedSceneLabel()
				);
		
		dm.setActualPC(
				FactoryDecoratedPlayerCharacter.getHero(
						dm.getFrame().getSelectedPCLabel()
						)
				);
		
		// Make this TG looped with game = true
		GameModel.getInstance().setGame(true);
		
		// Timer of the whole game session 
		GameModel.getInstance().setModelTimer(new ModelTimer(0,true));
		
		// Set the Mediator to manage PowerUp
		GameModel.getInstance().setPowerUpMediator(
				EnjoyPowerUpMediator.getInstance());

		GameModel.getInstance().getPowerUpMediator().reset();
		
		// Set the Mediator to manage NPCs
		GameModel.getInstance().setNpcMediator(
				EnjoyNpcMediator.getInstance());
		
		// Until now only if necessary the DynaSlaveGame showed LOADING
		this.setCurrentState(StateStarter.getInstance(this));
		
	}
	/**
	 * Repaint the view every delta's bar and
	 * mark the passage of a second.
	 */
	private void updateTimers() {
		// Repaint if Game is On every delta>=1 with Observable-Observer Pattern
		GameModel.getInstance().transmitGameOn(); 
		if(timerGeneral>=aSecondInNanos) { // reset timeGeneral to 0 about every second
			timerGeneral=0;
			speedrunTime++;
		}
		
	}
	/**
	 * It receives and records the input values ​​produced by the user within its fields.
	 */
	private void receivingOrders() { // User's inputs
		
		pause = keyLis.isPaused();
		
		enter = keyLis.isEnter();
		
		direction = keyLis.getDir();
		
		performAction = keyLis.isPerformAction();
		
		triggerAction = keyLis.isTriggerAction();
		
		// EXPOSE FUNC
		victory = keyLis.isVictory();
		
	}
	/**
	 * Check the conditions to kill this ThreadGame.
	 */
	private void ender() {
		
		if(gameOver) {
			
			doGameOver();
			
		} else if(escape) {
			
			doEscape();
			
		} else if(gameWin) {
			
			doGameWin();
			
		}
		
	}
	/**
	 * Kill this thread by escape mode.
	 */
	private void doEscape() {
		GameModel.getInstance().getCurrAccount().incEscapesTotal(); // register number_escape++
		exit();
	}
	/**
	 * Kill this thread by game over mode.
	 */
	private void doGameOver() {
		GameModel.getInstance().getCurrAccount().incFailuresTotal();// register number_gameOver++
		exit();

	}
	/**
	 * Kill this thread by stage win mode.
	 */
	private void doGameWin() { // only if you complete the stage
		GameModel.getInstance().getCurrAccount().incCompletedStagesTotal();// register number_gameWin++
		GameModel.getInstance().getCurrAccount().updateSpeedrunTime(speedrunTime);
		exit();
	}
	/**
	 * It adjusts the application parameters following the termination of this ThreadGame.
	 */
	private void exit() {
		GameModel.getInstance().getCurrAccount().updateBestScore(GameModel.getInstance().getScore());
		GameModel.getInstance().resetScore();
		GameModel.getInstance().getCurrAccount().incMatchesTotal();
		GameModel.getInstance().deleteObservers(); // remove DynaslaveGame from ObserverList
		GameModel.getInstance().setGame(false); 		// set gameOn = false and conclude this TG. changePanel("start")
	}

}
